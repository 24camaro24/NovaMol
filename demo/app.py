# app.py

import streamlit as st
import pandas as pd
import pipeline  # Your modular pipeline
from concurrent.futures import ProcessPoolExecutor, as_completed
import os

# --- Page Configuration ---
st.set_page_config(
    page_title="NovaMol AI Drug Discovery",
    page_icon="üíä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Session State Initialization ---
# This is crucial for managing the app's state across reruns
if 'job_future' not in st.session_state:
    st.session_state.job_future = None
if 'job_started' not in st.session_state:
    st.session_state.job_started = False
if 'results' not in st.session_state:
    st.session_state.results = None
if 'error' not in st.session_state:
    st.session_state.error = None

# --- Main App UI ---
st.title("üíä NovaMol: AI Drug Discovery Pipeline")
st.write("""
This application uses a Graph Neural Network (GNN) and a Recurrent Neural Network (RNN) 
to perform de novo drug discovery. Enter a ChEMBL Target ID, and the pipeline will:
1.  Download and process data for that target.
2.  Train predictive (GNN) and generative (RNN) models.
3.  Generate novel, drug-like molecules.
4.  Predict their properties and present the most promising candidates.
""")

st.sidebar.header("Configuration")
# Example IDs for user convenience
example_ids = ["CHEMBL203 (EGFR - Lung Cancer)", "CHEMBL240 (VEGFR2 - Angiogenesis)", "CHEMBL2094 (BACE1 - Alzheimer's)"]
selected_example = st.sidebar.selectbox("Select an example target:", options=example_ids)
target_id_input = st.sidebar.text_input(
    "Or enter a ChEMBL Target ID:", 
    value=selected_example.split(" ")[0] # Default to the example
)

# Use a ProcessPoolExecutor to run the pipeline in a separate process
executor = ProcessPoolExecutor(max_workers=1)

# The "Run Pipeline" button
if st.sidebar.button("üöÄ Run Discovery Pipeline"):
    if not target_id_input:
        st.sidebar.error("Please enter a ChEMBL Target ID.")
    else:
        # Reset state from previous runs
        st.session_state.job_started = True
        st.session_state.results = None
        st.session_state.error = None
        
        output_dir = f'results_{target_id_input}'
        # Submit the long-running function to the executor
        st.session_state.job_future = executor.submit(
            pipeline.run_complete_pipeline, 
            target_id=target_id_input,
            output_dir=output_dir
        )
        st.info(f"Pipeline started for target {target_id_input}. This will take a significant amount of time. Please wait.")

# --- Status and Results Display ---
if st.session_state.job_started:
    future = st.session_state.job_future
    
    # Check if the job is still running
    if not future.done():
        st.warning("‚è≥ Pipeline is running in the background. Please do not close this window.")
        st.info("Model training and molecule generation can take 20-30 minutes or more, depending on the data and hardware.")
        with st.spinner('Training models and generating molecules...'):
            # This is a blocking call that waits for the result
            try:
                st.session_state.results = future.result()
            except Exception as e:
                st.session_state.error = e

    # Once the job is done, display the results
    if st.session_state.results:
        st.success(f"‚úÖ Pipeline completed successfully for target {target_id_input}!")
        
        performance_report, csv_path = st.session_state.results
        
        st.header("1. Model Performance Report")
        st.write("This report shows the Mean Absolute Error (MAE) of the predictive GNN on the unseen test dataset.")
        
        cols = st.columns(len(performance_report))
        for i, (metric, value) in enumerate(performance_report.items()):
            cols[i].metric(label=metric, value=f"{value:.4f}")

        st.header("2. Novel Drug Candidates")
        st.write("Below are the novel molecules generated by the RNN, ranked by their predicted properties. The assessment provides a high-level view of their potential as drug candidates.")
        
        try:
            df_results = pd.read_csv(csv_path)
            st.dataframe(df_results)
            
            # Prepare the file for download
            with open(csv_path, "rb") as f:
                st.download_button(
                    label="üì• Download Results as CSV",
                    data=f,
                    file_name=os.path.basename(csv_path),
                    mime="text/csv",
                )
        except FileNotFoundError:
            st.error(f"Could not find the results file at {csv_path}.")

    elif st.session_state.error:
        st.error("An error occurred while running the pipeline:")
        st.exception(st.session_state.error)
